//! Debouncer definition.
//!
//! When pressed, switches don't give a clear state change: they
//! bounce. A debouncer filter these bounces. The current
//! implementation validate the state change when the state is stable
//! during a configurable number of update. 5 ms is the recommended
//! duration for keyboard switches.

use crate::layout::Event;

/// The debouncer type.
pub struct Debouncer<T> {
    cur: T,
    new: T,
    since: u16,
    nb_bounce: u16,
}

impl<T> Debouncer<T> {
    /// Create a new debouncer.
    ///
    /// `cur` and `new` corresponds to the initial state, they should
    /// be equal at start. Taking 2 states allows `new` to be a
    /// `const fn` and allows non clonable types to be used.
    ///
    /// `nb_bounce` corresponds to the number of updates with same state
    /// needed to validate the new state.
    pub const fn new(cur: T, new: T, nb_bounce: u16) -> Self {
        Self {
            cur,
            new,
            since: 0,
            nb_bounce,
        }
    }
}

impl<T: PartialEq> Debouncer<T> {
    /// Gets the current state.
    pub fn get_state(&self) -> &T {
        &self.cur
    }

    /// Updates the current state. Returns an iterator of new events if the state changes.
    pub fn update<'a, U: 'a>(&'a mut self, new: T) -> Option<impl Iterator<Item = Event> + 'a>
    where
        &'a T: IntoIterator<Item = U>,
        U: IntoIterator<Item = &'a bool>,
        U::IntoIter: 'a,
    {
        if self.cur == new {
            self.since = 0;
            return None;
        }

        if self.new != new {
            self.new = new;
            self.since = 1;
        } else {
            self.since += 1;
        }

        if self.since > self.nb_bounce {
            core::mem::swap(&mut self.cur, &mut self.new);
            self.since = 0;
            Some(self.events())
        } else {
            None
        }
    }

    /// Iterates on the `Event`s generated by the update.
    ///
    /// `T` must be some kind of array of array of bool.
    ///
    /// Panics if the coordinates don't fit in a `(u8, u8)`.
    ///
    /// # Example
    ///
    /// ```
    /// use keyberon::debounce::Debouncer;
    /// use keyberon::layout::Event;
    /// let mut debouncer = Debouncer::new(
    ///     [[false, false], [false, false]],
    ///     [[false, false], [false, false]],
    ///     2,
    /// );
    ///
    /// // no events
    /// assert!(debouncer.events([[false, false], [false, false]]).is_none());
    ///
    /// // `(0, 1)` is being pressed, but debouncer is filtering
    /// assert!(debouncer.events([[false, true], [false, false]]).is_none());
    /// assert!(debouncer.events([[false, true], [false, false]]).is_none());
    ///
    /// // `(0, 1)` is stable enough, event appears.
    /// let mut events = debouncer.events([[false, true], [false, false]]).unwrap();
    /// assert_eq!(events.next(), Some(Event::Press(0, 1)));
    /// assert_eq!(events.next(), None);
    /// ```
    pub fn events<'a, U>(&'a mut self) -> impl Iterator<Item = Event> + 'a
    where
        &'a T: IntoIterator<Item = U>,
        U: IntoIterator<Item = &'a bool>,
        U::IntoIter: 'a,
    {
        self.new
            .into_iter()
            .zip(self.cur.into_iter())
            .enumerate()
            .flat_map(move |(i, (o, n))| {
                o.into_iter()
                    .zip(n.into_iter())
                    .enumerate()
                    .filter_map(move |(j, bools)| match bools {
                        (false, true) => Some(Event::Press(i as u8, j as u8)),
                        (true, false) => Some(Event::Release(i as u8, j as u8)),
                        _ => None,
                    })
            })
    }
}
